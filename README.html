<!DOCTYPE html>
<html>
<head>
<title>README.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>
<link rel="stylesheet" href="file:///d%3A/Projects/BilinearInterpolation-OpenCL-OpenCV/style.css" type="text/css">
<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="interpolacja-bilinearna-przy-pomocy-karty-graficznej-i-frameworka-opencl">Interpolacja Bilinearna przy pomocy karty graficznej i frameworka OpenCL</h1>
<p>Marek Kasprowicz</p>
<p><img src="https://user-images.githubusercontent.com/67783947/214853195-78096f40-2fc1-443e-bb94-80d51c481cf6.png" alt="image"></p>
<p><em>Przeskalowany obraz z 420x420 na 600x600 przy pomocy karty graficznej i frameworka OpenCL</em></p>
<h1 id="interpolacja-bilinearna-1234">Interpolacja Bilinearna [^1][^2][^3][^4]</h1>
<p>Proces stosowany przy skalowaniu zbiorów danych, najczęściej obrazów. Polega on na wyznaczniu wartości dla nowej struktury danych w oparciu o informacje zawarte w pierwszej. Należy dla każdego nowego elementu tablicy znaleźć cztery wartości odpowiadające mu w początkowej tablicy i wyznaczyć nowe na podstawie odległości od tych punktów.</p>
<p>W pierwszej kolejności należy stworzyć pusty obraz odpowiednio przeskalowany, a następnie należy wyznaczyć skalę powiększenia.</p>
<pre class="hljs"><code><div>	ratio_x = input.width / output.width
	ratio_y = input.height / output.height
</div></code></pre>
<p>Pozwoli to na wyznaczanie odpowiadających indeksów w drugim obrazie.</p>
<pre class="hljs"><code><div>	x = x_ratio * j
	y = y_ratio * i
</div></code></pre>
<p>Ponieważ wartością x i y będą zmienne zmiennoprzecinkowe, to po zastosowaniu ceil i floor w łatwy sposób wyznaczamy punkty przegowe, pomiędzy którymi znajduje się interesujący nas punkt.</p>
<p><img src="https://user-images.githubusercontent.com/67783947/214845955-61923764-54e1-49ed-860c-0d679e948ac8.png" alt="obraz"></p>
<p>Następnie wyznacza się zmienną ciężkości, określającą drogę przebytą między dwoma bocznymi pikselami.</p>
<pre class="hljs"><code><div>	xw = (x_ratio * j) - x0
	yw = (y_ratio * i) - y0
</div></code></pre>
<p>Na końcu zastosowuje się dla każdego koloru piksela wyprowadzony wzór[^8] na interpolację między czterema punktami:</p>
<p><img src="https://user-images.githubusercontent.com/67783947/214850321-968c41d9-be33-4512-a998-f54006c982e6.png" alt="obraz"></p>
<h1 id="opencl-56">OpenCL [^5][^6]</h1>
<p>Opensourcowy framework stosowany do tworzenia oprogramowania na różnych ALU. W przeciwieństwie do CUDA nie jest ograniczony tylko do konkretnego rodzaju hardware. Raz napisany kod w OpenCL można uruchomić na niemalże każdym sprzęcie, wliczając w to GPU, CPU lub FPGA). Aktaulnie jest w posiadaniu grupy Khronos i najwyższą jego wersją jest 3.0. Natywnie kod OpenCL tworzy się za pomocą języka C, jednak Khronos wprowadził headery interpretujące polecenia na obiekty C++, co znacznie poprawiło czytelność kodu i zmniejszyło &quot;biolerplate&quot;.
Istnieją również nakładki na inne języki takie jak:</p>
<ol>
<li>Python - https://pypi.org/project/pyopencl/</li>
<li>Java - https://github.com/gpu/JOCL</li>
<li>C# - https://www.nuget.org/packages/OpenCL.Net</li>
<li>C++ - https://github.com/KhronosGroup/OpenCL-CLHPP</li>
</ol>
<h1 id="om%C3%B3wienie-kodu">Omówienie kodu</h1>
<p>Projekt składa się z 5 plików:</p>
<ul>
<li><em>main.cpp</em> - Wczytuje obraz, wywołuje skalowanie na GPU i CPU. Zbiera czas wykonywania i zapisuje do plików .csv.</li>
<li><em>CPU.cpp</em>- Algorytm dwuliniowej interpolacji wykonywany sekwencyjnie na procesorze, przy pomocy obiektów biblioteki OpenCV.</li>
<li><em>GPU.cpp</em> - Plik przygotowywujący GPU i konwertujący obraz OpenCV do formatu możliwego do przekazania dla GPU.</li>
<li><em>bilinear_interpolation.cl</em> - Algorytm dwuliniowej interpolacji wykonywalny na GPU, jest wczytywany w GPU.cpp.</li>
<li><em>/test/plot.py</em> - Interpretuje dane zebrane podczas testów i pokazuje je w formie wykresu.</li>
</ul>
<p>Oprócz tego znajdują się tu pliki:</p>
<ul>
<li><em>image.png</em> - Testowy obraz do skalowania.</li>
<li><em>test/cpu.csv</em> - Wyniki testów dla cpu.</li>
<li><em>test/gpu.csv</em> - Wyniki testów dla gpu.</li>
<li><em>test/gpuVScpu.png</em> - Wykres porównania.</li>
<li><em>README.md</em>, <em>README.html</em>, <em>README.pdf</em> - dokumentacja projektu (html i pdf zostały wygenerowane z README.md).</li>
</ul>
<p>Najważniejszą częścią projektu są pliki main.cpp, GPU.cpp i bilinear_interpolation.cl, dzięki nim wywołuje się algorytm interpolacji na GPU.</p>
<h2 id="wczytanie-obrazu-z-dysku-twardego">Wczytanie obrazu z dysku twardego</h2>
<p>Do manipulacji obrazami wykorzystana została biblioteka OpenCV, importowalna przez bibliotekę <em>&lt;opencv2/opencv.hpp&gt;</em>.</p>
<pre class="hljs"><code><div>  cv::Mat load_image(string file_name) {
      cv::Mat image = cv::imread(file_name);
      if (image.empty()) {
          cout &lt;&lt; &quot;Image not loaded&quot; &lt;&lt; endl;
      }

      cv::cvtColor(image, image, cv::COLOR_BGR2RGBA);
      return image;
  }
</div></code></pre>
<p>Metoda zwraca obraz w obiekcie cv::Mat, który jest strukturą danych przechowywującą kolory pikseli. Warto zwrócić uwagę, że format jest konwertowany z BGR na RGBA, gdyż wczytywanie obrazów przez OpenCL jest zoptymalizowane dla 4 wartości.</p>
<h2 id="platformy-i-urz%C4%85dzenia">Platformy i urządzenia</h2>
<p>Na początku bloku kodu OpenCL należy zadeklarować z jakiej platformy i jakiego urządzenia będzie się korzystać.</p>
<pre class="hljs"><code><div>  void setup_device(cl::Platform &amp;platform, cl::Device &amp;device) {
      std::vector&lt;cl::Platform&gt; all_platforms;
      cl::Platform::get(&amp;all_platforms);
      if (all_platforms.size() == 0) {
          std::cout &lt;&lt; &quot; 0 platforms \n&quot;;
          exit(1);
      }

      platform = all_platforms[0];

      std::vector&lt;cl::Device&gt; all_devices;
      platform.getDevices(CL_DEVICE_TYPE_ALL, &amp;all_devices);
      if (all_devices.size() == 0) {
          std::cout &lt;&lt; &quot; 0 devices\n&quot;;
          exit(1);
      }

      device = all_devices[0];
  }
</div></code></pre>
<p>Metoda ta zwraca pierwszą platformę i pierwsze urządzenie w niej zawarte. Jest to łatwy sposób na testowanie programu na wielu urządzeniach, jeśli tylko posiada się urządzenia wspierające OpenCL.</p>
<p>Aby wyświetlić informacje o platformach i urządzeniach, należy wykonać na nich metodę getInfo.</p>
<pre class="hljs"><code><div>  std::cout &lt;&lt; platform.getInfo&lt;CL_PLATFORM_NAME&gt;() &lt;&lt; &quot;: &quot; &lt;&lt; device.getInfo&lt;CL_DEVICE_NAME&gt;() &lt;&lt; &quot;\n&quot;
</div></code></pre>
<h2 id="kontekst-kolejka-zada%C5%84-program-i-kod-j%C4%85dra">Kontekst, kolejka zadań, program i kod jądra</h2>
<p>W poniższym kodzie występuje deklaracja urządzenia na którym program ma wykonywać zadania, oraz do źródła zostaje wczytany plik <em>bilinear_interpolation.cl</em> posiadający instrukcje dla GPU. Program zostaje zbudowany, a potem tworzony jest Kernel, ze wskazaniem która metoda z wczytanego pliku zostanie wywołana.</p>
<pre class="hljs"><code><div>    cl::Context context({ device });
    cl::CommandQueue queue(context, device, CL_QUEUE_PROFILING_ENABLE);

    cl::Program::Sources sources;
    string kernel_code = get_kernel(&quot;bilinear_interpolation.cl&quot;);
    sources.push_back({ kernel_code.c_str(), kernel_code.length() });

    cl::Program program(context, sources);
    if(program.build({ device }) != CL_SUCCESS) {
        std::cout &lt;&lt; &quot;Error building: &quot; &lt;&lt; program.getBuildInfo&lt;CL_PROGRAM_BUILD_LOG&gt;(device) &lt;&lt; &quot;\n&quot;;
        exit(1);
    }

    cl::Kernel kernel(program, &quot;bilinear_interpolation&quot;);
</div></code></pre>
<h2 id="kernel">Kernel</h2>
<p>Polecenia wykonywalne przez urządzenie OpenCL, realizujące interpolację. Oznaczony jest flagą <em>__kernel</em></p>
<h3 id="samplert">sampler_t</h3>
<pre class="hljs"><code><div>  __constant sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE|CLK_ADDRESS_CLAMP|CLK_FILTER_NEAREST;
</div></code></pre>
<p>Sampler jest obiektem koniecznym do manipulacji obrazem. Ustawia się na nim flagi odnoszące się np. do normalizacji koordynatów, przybliżania lokaliazcji czy specyfikacji adresowej.</p>
<h3 id="image2dt">image2d_t</h3>
<p>Reprezentacja obiektu <em>cl::Image2D</em> wewnątrz kodu kernela. Aby manipulować danymi sotsuje się dwie metody:</p>
<pre class="hljs"><code><div>  read_imagef(image, sampler, (int2)(x, y))
  write_imagef(image, (int2)(x, y), color)
</div></code></pre>
<p>Kolor jest przestawiony jako typ <em>float4</em>, czyli wektor czterech floatów, gdzie:</p>
<pre class="hljs"><code><div>  red:    float4.x 
  green:  float4.y
  blue:   float4.z
  alpha:  float4.w
</div></code></pre>
<h3 id="getglobalidn">get_global_id(n)</h3>
<p>Używany do uzyskania indeksu &quot;obrotu pętli&quot; w kernelu, która jest deklarowany w <em>cl::NDRange</em>. Ponieważ w kodzie została wywołana opcja dwuargumentowa, więc dostępne są dwa identyfikatory pod indeksem 0 i 1.</p>
<pre class="hljs"><code><div>	int i = get_global_id(0);
	int j = get_global_id(1);
</div></code></pre>
<h3 id="modyfikatory">Modyfikatory</h3>
<p>Modyfikatory zmiennych pozwalają na przyspieszenie obliczeń, gdyż urządzenie odwołuje się do konkretnych adresów.</p>
<pre class="hljs"><code><div>  __read_only
  __write_only
  const
</div></code></pre>
<h2 id="za%C5%82adowanie-i-konwersja-obrazu-dla-gpu">Załadowanie i konwersja obrazu dla GPU</h2>
<p>Projekt stosuje OpenCV[^7] do pracy na obrazach. Aby obiekt cv::Mat mógł być zrozumiany przez GPU musi on być zmapowany do wektora o wielkości <strong>height * width * 4</strong>.</p>
<pre class="hljs"><code><div>  Piksele w obrazie 2d:   [0, 0]      [0, 1]          [n, n]
  Piksele w tablicy 1d: { r, g, b, a, r, g, b, a, ... r, g, b, a }
</div></code></pre>
<p>Po konwersji należy zadeklarować obiekt <em>cl::Image2D</em> służacy do przekazania danych do GPU. Do obiektu należy przekazać kontekst, stwierdzić z jaką flagą ma być odczytywany w funkcji kernelowej, określić format przy pomocy <em>cl::ImageFormat</em> (format kolorów i ty zmiennych w tablicy 1d), oraz rozmiar zadeklarowanego obrazu.</p>
<pre class="hljs"><code><div>  cl::ImageFormat format(CL_RGBA, CL_UNORM_INT8);
  cl::Image2D Input_Image(context, CL_MEM_READ_ONLY, format, input_image.size().width, input_image.size().height);
  cl::Image2D Output_Image(context, CL_MEM_WRITE_ONLY, format, image_size, image_size);
</div></code></pre>
<p>Aby załadować obraz do jądra, należy jeszcze określić koordynaty początku i końca obrazu.</p>
<pre class="hljs"><code><div>  queue.enqueueWriteImage(Input_Image, CL_TRUE, origin, input_region, 0, 0, &amp;input_arr[0]);
</div></code></pre>
<h2 id="wywo%C5%82anie-programu-j%C4%85dra">Wywołanie programu jądra</h2>
<p>Przekazywanie obiektów do jądra wykonuje się przy pomocy metody setArg, gdzie należy wskać na indeks obiektu i go przekazać.
Program rozpocznie się gdy wywołamy na kolejce <em>enqueueNDRangeKernel</em>, która uruchamia pętlę o wielkości zadeklarowanej w <em>cl::NDRange</em>.</p>
<pre class="hljs"><code><div>  kernel.setArg(0, Input_Image);
  kernel.setArg(1, Output_Image);
  kernel.setArg(2, sizeof(float), &amp;x_ratio);
  kernel.setArg(3, sizeof(float), &amp;y_ratio);

  queue.enqueueNDRangeKernel(kernel, cl::NullRange, cl::NDRange(image_size, image_size), cl::NullRange, NULL);
</div></code></pre>
<p>cl::NDRange(image_size, image_size) jest odpowiednikiem pętli:</p>
<pre class="hljs"><code><div>  for(int i = 0; i &lt; image_size; i++) {
    for(int j = 0; j &lt; image_size; j++) {
      ...
    }
  }
</div></code></pre>
<h2 id="odczyt-danych-i-zapis-obrazu">Odczyt danych i zapis obrazu</h2>
<p>Odczytanie obrazu realizuje metoda enqueueReadImage, zachowująca się bliźniaczo do enqueueWriteImage. Obraz jest zapisany w zmiennej output_arr, a potem przekonwertowany na obiekt cv::Mat.</p>
<pre class="hljs"><code><div>  std::vector&lt;uchar&gt; output_arr(image_size * image_size * 4);
  queue.enqueueReadImage(Output_Image, CL_TRUE, origin, output_region, 0, 0, &amp;output_arr[0]);
  cv::Mat output_image(image_size, image_size, CV_8UC4, output_arr.data());
</div></code></pre>
<h2 id="pomiar-czasu">Pomiar czasu</h2>
<p>Czas wykonania mierzony jest przy pomocy biblioteki <em>chrono</em> i nie zawiera on wczytywania i zapisywania obrazu na dysk, ponieważ nie są to istotne dla równoległości elementy.</p>
<h1 id="por%C3%B3wnanie-gpu-i-cpu">Porównanie GPU i CPU</h1>
<h2 id="czasy-wykonania">Czasy wykonania</h2>
<p>W trybie testu projekt tworzy pliki gpu.csv i cpu.csv zawierające czase wykonania skalowania obrazów z zakresu 100-10000, wykonywanywanego co 100 pikseli. Przy pomocy skryptu <em>/test/plot.py</em> są interpretowane i konwertowane do wykresu.</p>
<p><img src="https://user-images.githubusercontent.com/67783947/214837763-02b47c5e-a059-4488-a6b1-54a41465ecef.png" alt="obraz"></p>
<p>Czasy wykonywania z początku są równe, bądź nawet lepsze dla CPU. Trend ten zmienia się gdy należy przeskalować obraz do formatu 300x300. Od tego czasu wykładniczo zwiększa się czas wykonania dla CPU, podczas gdy GPU oscyluje na podobnym poziomie, jednak może to być spowodowane operacjami tworzenia wektorów obrazów i zamiany ich na cv::Mat.</p>
<p>W finalnym punkcie czas wykonania dla CPU jest aż <em>81,20</em> razy większy niż programu na GPU.</p>
<h2 id="poprawno%C5%9B%C4%87-obraz%C3%B3w">Poprawność obrazów</h2>
<p>Obrazy wykonane przez cpu i gpu są identyczne. Można to sprawdzić przy pomocy narzędzia wykrywającego zmiany w obrazach online np. https://products.groupdocs.app/comparison/compare?FolderName=0b8244d6-fd84-4c2b-9180-36429426cc98&amp;FirstFileName=cpu_out.png&amp;SecondFileName=gpu_out.png</p>
<p><img src="https://user-images.githubusercontent.com/67783947/214844250-e217cb37-d631-4a29-ac07-b3a28851f448.png" alt="obraz"></p>
<h1 id="biblioteki-kompilacja-i-uruchamianie">Biblioteki, kompilacja i uruchamianie</h1>
<h2 id="opencl">OpenCL</h2>
<pre class="hljs"><code><div>sudo apt install opencl-headers ocl-icd-opencl-dev -y
</div></code></pre>
<h2 id="opencv">OpenCV</h2>
<pre class="hljs"><code><div>sudo apt install python3-opencv libopencv-dev 
</div></code></pre>
<h2 id="kompilacja">Kompilacja</h2>
<pre class="hljs"><code><div>g++ main.cpp -lOpenCL `pkg-config --cflags --libs opencv4`
</div></code></pre>
<h2 id="wywo%C5%82anie">Wywołanie</h2>
<pre class="hljs"><code><div>./a.out [plik_wejsciowy] [plik_wyjsciowy] [rozmiar_nowego_pliku] [tryb_testowy]
</div></code></pre>
<ul>
<li>[plik_wejsciowy] - Nazwa pliku wejściowego. Np. &quot;in.png&quot;</li>
<li>[plik_wyjsciowy] - Nazwa pliku wyjściowego. Np. &quot;out.png&quot;</li>
<li>[rozmiar_nowego_pliku] - Miara do której będzie skalowany obraz, podany w pixelach. Np. 100</li>
<li>[tryb_testowy] - W trybie testowym nie są produkowane obrazy wyjścia, jednak tworzą się pliki z danymi.
<ul>
<li>0 - brak testów</li>
<li>1 - testowanie</li>
</ul>
</li>
</ul>
<h2 id="biblioteki-do-wykres%C3%B3w">Biblioteki do wykresów</h2>
<pre class="hljs"><code><div>pip install pandas
pip install matplotlib
</div></code></pre>
<h2 id="wywo%C5%82anie-kodu-rysuj%C4%85cego-wykres">Wywołanie kodu rysującego wykres</h2>
<pre class="hljs"><code><div>python3 plot.py
</div></code></pre>
<h1 id="komentarz-osobisty">Komentarz osobisty</h1>
<p><img src="https://user-images.githubusercontent.com/67783947/214385523-95a341e2-3cbd-456c-84bf-f466d6a8860c.png" alt="obraz"></p>
<p>Praca z biblioteką OpenCL była bardzo trudna. Istniejące materiały są przestarzałe i odnoszą się najczęściej do wersji C. Ogólnie rzecz biorąc istnieje bardzo mała ilość użytecznych przykładów, a dochodzenie do sensownego rozwiązania zajmuje sporo czasu. Najwięcej czasu zajęła mi konwersja obiektu cv::Mat na formę odczytywalną przez GPU, problemy z którymi się spotkałem to: niepoprawny format danych (BGR zamiast RGBA), konwersja uchar na float czy problemy z odczytaniem poprawnych wartości przez GPU.</p>
<h1 id="%C5%BAr%C3%B3d%C5%82a">Źródła</h1>
<p>[^1]: Bilinear Interpolation Calculator: https://www.omnicalculator.com/math/bilinear-interpolation
[^2]: Zmiana wielkości obrazu - Interpolacja dwuliniowa: http://www.algorytm.org/przetwarzanie-obrazow/zmiana-wielkosci-obrazu-interpolacja-dwuliniowa.html
[^3]: The AI Learner Bilinear Interpolation: https://theailearner.com/2018/12/29/image-processing-bilinear-interpolation/
[^4]: Understanding Bilinear Image Resizing: https://chao-ji.github.io/jekyll/update/2018/07/19/BilinearResize.html
[^5]: Khronos OpenCL Guide: https://github.com/KhronosGroup/OpenCL-Guide
[^6]: OpenCL Programming by Example By Ravishekhar Banger, Koushik Bhattacharyya: https://www.packtpub.com/product/opencl-programming-by-example/9781849692342
[^7]: OpenCV C++ Tutorial: https://www.opencv-srf.com/2017/11/load-and-display-image.html
[^8]: Interpolacja dwuliniowa: https://pl.wikipedia.org/wiki/Interpolacja_dwuliniowa</p>

</body>
</html>
